{"version":3,"sources":["util/parsers.js"],"names":["parseProduce","parseUpdate","parseId","input","requirements","key","type","every","req","hasOwnProperty","validKeys","trimmed","Object","keys","reduce","obj","curr","indexOf","length","id","parseInt"],"mappings":";;;;;;;;QAAgBA,Y,GAAAA,Y;QAcAC,W,GAAAA,W;QAcAC,O,GAAAA,O;AA5BT,SAASF,YAAT,CAAsBG,KAAtB,EAA2C;AAChD,MAAMC,eAAe,CACnB,EAAEC,KAAK,MAAP,EAAeC,MAAM,QAArB,EADmB,EAEnB,EAAED,KAAK,UAAP,EAAmBC,MAAM,QAAzB,EAFmB,EAGnB,EAAED,KAAK,OAAP,EAAgBC,MAAM,QAAtB,EAHmB,CAArB;AAKA,SAAOF,aAAaG,KAAb,CAAmB,UAACC,GAAD,EAAS;AACjC,WAAOL,MAAMM,cAAN,CAAqBD,IAAIH,GAAzB,KAAiC,QAAOF,MAAMK,IAAIH,GAAV,CAAP,MAA0BG,IAAIF,IAAtE;AACD,GAFM,CAAP;AAGD;;AAED;AACA;AACA;AACO,SAASL,WAAT,CAAqBE,KAArB,EAA6C;AAClD,MAAMO,YAAY,CAAC,MAAD,EAAS,UAAT,EAAqB,OAArB,CAAlB;AACA,MAAMC,UAAUC,OAAOC,IAAP,CAAYV,KAAZ,EAAmBW,MAAnB,CAA0B,UAACC,GAAD,EAAMC,IAAN,EAAe;AACvD,QAAID,OAAOL,UAAUO,OAAV,CAAkBD,IAAlB,MAA4B,CAAC,CAAxC,EAA2C;AACzCD,UAAIC,IAAJ,IAAYb,MAAMa,IAAN,CAAZ;AACA,aAAOD,GAAP;AACD;AACF,GALe,EAKb,EALa,CAAhB;AAMA,SAAQJ,WAAWC,OAAOC,IAAP,CAAYF,OAAZ,EAAqBO,MAArB,GAA8B,CAA1C,GAA+CP,OAA/C,GAAyD,IAAhE;AACD;;AAGD;AACA;AACO,SAAST,OAAT,CAAiBC,KAAjB,EAA+C;AACpD,MAAIA,MAAMM,cAAN,CAAqB,IAArB,CAAJ,EACE,OAAQ,OAAON,MAAMgB,EAAb,KAAoB,QAArB,GAAiCC,SAASjB,MAAMgB,EAAf,EAAmB,EAAnB,CAAjC,GAA0DhB,MAAMgB,EAAvE;AACF,SAAO,KAAP;AACD","file":"parsers.js","sourcesContent":["export function parseProduce(input: any): boolean {\n  const requirements = [\n    { key: 'name', type: 'string' },\n    { key: 'quantity', type: 'number' },\n    { key: 'price', type: 'number' }\n  ];\n  return requirements.every((req) => {\n    return input.hasOwnProperty(req.key) && typeof input[req.key] === req.type;\n  });\n}\n\n//parseUpdate takes in the payload from the request,\n//and strips out any keys that are not name, quantity, or price.\n//Then it just simply returns the trimmed object if thereâ€™s still keys left, and null if not.\nexport function parseUpdate(input: any): any | null {\n  const validKeys = ['name', 'quantity', 'price'];\n  const trimmed = Object.keys(input).reduce((obj, curr) => {\n    if (obj && validKeys.indexOf(curr) !== -1) {\n      obj[curr] = input[curr];\n      return obj;\n    }\n  }, {});\n  return (trimmed && Object.keys(trimmed).length > 0) ? trimmed : null;\n}\n\n\n//parseId is even simpler: It looks for an id property on\n//the payload, converts it to a number (if necessary), and returns.\nexport function parseId(input: any): number | boolean {\n  if (input.hasOwnProperty('id'))\n    return (typeof input.id === 'string') ? parseInt(input.id, 10) : input.id;\n  return false;\n}\n"]}